#################################################
# Qualys Vulnerability Report Automation Script #
# Author: Jared Scott                           #
# Revision: 2 Date: Oct 7, 2014                 #
#################################################

#api setup
$username = "CHANGEME"
$password = "CHANGEME"
$headers = @{"X-Requested-With"="powershell"} #Create a hashtable with all the necessary headers

#various options
$sleep_time = 60 #seconds.
$format = "html" #qualys report type
$template_id = "111111" #historical vulnerability template
$working_dir = "C:\temp"
$report_dir = "\\some\file\share"

##Step 1. Read Assets from CSV into an Array
Set-Location -Path $working_dir #change to the working directory
$csv = "C:\some\path\qualys_assets_1.csv" #The script uses this CSV to define what assets you want to run reports for.
$assets = Import-Csv $csv -Delimiter : #Since the Qualys APIs are generally comma and ampersand heavy, I chose to delimit on colons.

##Step 2. Create an array of asset names and API calls
$asset_names = @() #Initialize the array
$asset_names = $assets | foreach-object {"{1}" -f $_.Environment,$_.Name,$_.Assets}
$api_urls = $assets | foreach-object {"https://qualysapi.qualys.com/api/2.0/fo/report/?action=launch&output_format=$format&template_id=$template_id&report_title=Operational%20-%20Environment%3A%20{1}%20-%20{0}&asset_group_ids={2}" -f $_.Environment,$_.Name,$_.Assets}

##Step 3. Invoke the Qualys API to launch each report, poll the report status and wait until finished. Iterate through reports one at a time since qualys has a 7 concurrent report limit. This could be improved to do 7 at a time.
[xml]$xml_login = Invoke-RestMethod -Headers $headers -SessionVariable QualysSession -Uri "https://qualysapi.qualys.com/api/2.0/fo/session/?action=login&username=$username&password=$password" -Method Post #Create a login session
$xml_login_status = $xml_login.simple_return.response.text
Write-Host Qualys login status: $xml_login_status

Write-Host Please wait while invoking $api_urls.Count reports.
$report_ids = @() #Initialize the array

foreach ($api_call in $api_urls) { #start iterating through report generation requests
    $current_reportID = $null #initialize variable
	$xml_status = $null #initialize variable
	[xml]$xml_return = Invoke-RestMethod -Headers $headers -WebSession $QualysSession -Uri "$api_call" -Method Post #Execute the API calls in the api_urls array and catch the XML responses
    $current_reportID = $xml_return.simple_return.response.item_list.item.value #Put the returned report ID into a working variable for this loop.
	$report_ids += $xml_return.simple_return.response.item_list.item.value #Put the returned report ID into an array for later.
	Start-Sleep $sleep_time #Give enough time for the report to launch and queue.
	do { #Poll the report and wait for finish.
        [xml]$xml_reportlist = Invoke-RestMethod -Headers $headers -WebSession $QualysSession -Uri "https://qualysapi.qualys.com/api/2.0/fo/report/?action=list&id=$current_reportID" #Get the report status and catch the XML response
        $xml_status = $xml_reportlist.report_list_output.response.report_list.report.status.state #Catch the state
        write-host "Waiting for report $current_reportID to finish. Sleeping $sleep_time seconds." #Communicate what is happening
        Start-Sleep $sleep_time #Sleep
    }
    while ($xml_status -eq "Running") #While the report is running then sleep.
}

##Step 4. Correlate names to launched report IDs into a hash table and check to see if they are finished.
$launched_reports =@{} #Initialize a hash table
for ( $n = 0; $n -lt $asset_names.Count; $n++ ) { #Find how many assets to iterate through
    $launched_reports.Add($asset_names[$n], $report_ids[$n]) #Combine the asset and id arrays into a table for iteration
}

##Step 5. Download the reports for each asset
$zipfiles = @() #Initialize an array to store the downloaded file names
foreach ($name in $launched_reports.GetEnumerator()) {
   $outfile = "$($name.Name)-VULN.zip" #Create a variable for the report file name
   $zipfiles += $outfile #Create an array for the downloaded zip files
   $report = "$($name.Value)" #Create a variable for the report id
   Invoke-RestMethod -Headers $headers -WebSession $QualysSession -Uri "https://qualysapi.qualys.com/api/2.0/fo/report/?action=fetch&id=$report" -Method Post -Outfile $working_dir\$outfile #Download the reports to the working directory
   Write-Host Downloading $outfile for report ID $report.
}

##Step 6. Correlate names to downloaded zip files into a hash table
$downloaded_reports = @{} #Initialize a hash table
for ( $n = 0; $n -lt $asset_names.Count; $n++ ) { #Find how many assets to iterate through
    $downloaded_reports.Add($asset_names[$n], $zipfiles[$n]) #Combine the asset and zips arrays into a table for iteration
}

##Step 7. Extract the zips in the current working directory
Write-Host Please wait while extracting $report_ids.Count reports.
foreach ($zip in $downloaded_reports.GetEnumerator()) {
    $shell_app=new-object -com shell.application #call .net
    $filename = "$($zip.Value)" #grab the zip name from the hash table
    $zip_file = $shell_app.namespace((Get-Location).Path + "\$filename") #unzip
    $destination = $shell_app.namespace((Get-Location).Path) #destination
    $destination.Copyhere($zip_file.items(), 0x10) #0x10 overwrites destination, 0x14 would combine and overwrite
}

##Step 8. Get the unzipped directories and correlate the names
$zipdir = @() #Initialize an array for the zip directories
foreach ($name in $asset_names) { $zipdir += Get-ChildItem $working_dir -recurse | Where-Object {$_.PSIsContainer -eq $true -and $_.Name -match "$name"} | ForEach-Object {$_.Name}} #Find the unzipped directories

$extract_directories = @{} #Initialize a hash table
for ( $n = 0; $n -lt $asset_names.Count; $n++ ) { #Find how many assets to iterate through
    $extract_directories.Add($asset_names[$n], $zipdir[$n]) #Combine the asset and zipdir arrays into a table for iteration
}

##Step 9. Move the reports to sharepoint and clean up
Write-Host Please wait while moving $report_ids.Count reports. This can be REALLY slow on itportal.
foreach ($move in $extract_directories.GetEnumerator()) { 
	Write-Host Moving $($move.Name) report.
	Move-Item "$working_dir\$($move.Value)\*.*" "$report_dir\$($move.Name)\Vuln" -force } #Move each report to sharepoint cifs share

foreach ($deletereport in $report_ids) { #Qualys has a limited amount of reports that can be stored in QualysGuard. The reports expire after 7 days, but with so many assets it can quickly fill so we have to delete.
	[xml]$xml_deleted_return = Invoke-RestMethod -WebSession $QualysSession -Headers $headers -Uri "https://qualysapi.qualys.com/api/2.0/fo/report/?action=delete&id=$deletereport" -Method Post
	$current_deleted_report = $xml_deleted_return.simple_return.response.item_list.item.value
	Write-Host Deleted Qualys report ID $current_deleted_report.
	}

[xml]$xml_logout = Invoke-RestMethod -Headers $headers -WebSession $QualysSession -Uri "https://qualysapi.qualys.com/api/2.0/fo/session/?action=logout" -Method Post #Logout
$xml_logout_status = $xml_logout.simple_return.response.text
Write-Host Qualys logout status: $xml_logout_status

Write-Host Deleting temp files.
foreach ($deletedir in $extract_directories.GetEnumerator()) { Remove-Item "$working_dir\$($deletedir.Value)\" } #delete extracted folders
foreach ($deletezip in $downloaded_reports.GetEnumerator()) { Remove-Item "$working_dir\$($deletezip.Value)" } #delete downloaded zips

Write-Host Done.