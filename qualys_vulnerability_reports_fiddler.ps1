#################################################
# Qualys Vulnerability Report Automation Script #
# Author: Jared Scott                           #
# Revision: 1 Date: Oct 2, 2014                 #
#################################################

#bypass certificate trust for fiddler
add-type @"
    using System.Net;
    using System.Security.Cryptography.X509Certificates;
    public class TrustAllCertsPolicy : ICertificatePolicy {
        public bool CheckValidationResult(
            ServicePoint srvPoint, X509Certificate certificate,
            WebRequest request, int certificateProblem) {
            return true;
        }
    }
"@
[System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy

#api setup
$username = "CHANGEME"
$password = "CHANGEME"
$rest_creds = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($username + ":" + $password)) #Convert credentials to Base64
$headers = @{"X-Requested-With"="powershell";"Authorization" = "Basic " + "$rest_creds"} #Create a hashtable with all the necessary headers

#various options
$format = "html" #qualys report type
$template_id = "111111" #historical vulnerability template
$working_dir = "C:\some\path"
$report_dir = "\\some\file\share"

##Step 1. Read Assets from CSV into an Array
Set-Location -Path $working_dir #change to the working directory
$csv = "$working_dir\assets.csv" #The script uses this CSV to define what assets you want to run reports for.
$assets = Import-Csv $csv -Delimiter : #Since the Qualys APIs are generally comma and ampersand heavy, I chose to delimit on colons.

##Step 2. Create an array of asset names
$asset_names = @() #Initialize the array
$asset_names = $assets | foreach-object {"{1}" -f $_.Environment,$_.Name,$_.Assets}

##Step 3. Create an array of Qualys API URLs for each report
$api_urls = $assets | foreach-object {"https://qualysapi.qualys.com/api/2.0/fo/report/?action=launch&output_format=$format&template_id=$template_id&report_title=Operational%20-%20Environment%3A%20{1}%20-%20{0}&asset_group_ids={2}" -f $_.Environment,$_.Name,$_.Assets}

##Step 4. Invoke the Qualys API to launch the reports, then grab the XML response that has the report IDs
Write-Host Please wait while invoking $api_urls.Count reports.
$report_ids = @() #Initialize the array
foreach ($api_call in $api_urls) { #start iterating through report generation requests
    [xml]$xml_return = Invoke-RestMethod -Headers $headers -Uri "$api_call" -Method Post -Proxy http://127.0.0.1:8888 #Execute all the API calls in the api_urls array and catch the XML responses
    $report_ids += $xml_return.simple_return.response.item_list.item.value #Put the returned report IDs into an array.
}

##Step 5. Correlate names to launched report IDs into a hash table and check to see if they are finished.
$launched_reports =@{} #Initialize a hash table
for ( $n = 0; $n -lt $asset_names.Count; $n++ ) { #Find how many assets to iterate through
    $launched_reports.Add($asset_names[$n], $report_ids[$n]) #Combine the asset and id arrays into a table for iteration
}

Write-Host Please wait while generating $report_ids.Count reports.

foreach ($state in $launched_reports.GetEnumerator()) { #Poll the API and wait for the reports to finish.
    do {
        [xml]$xml_reportlist = Invoke-RestMethod -Headers $headers -Uri "https://qualysapi.qualys.com/api/2.0/fo/report/?action=list&id=$($state.Value)" -Proxy http://127.0.0.1:8888
        $xml_status = $xml_reportlist.report_list_output.response.report_list.report.status.state
        write-host "Waiting for Report $($state.Value) to finish."
        Start-Sleep 120
    }
    while ($xml_status -eq "Running")
}

##Step 6. Download the reports for each asset
Write-Host Please wait while downloading $report_ids.Count reports.

$zipfiles = @() #Initialize an array to store the downloaded file names
foreach ($name in $launched_reports.GetEnumerator()) {
   $outfile = "$($name.Name)-VULN.zip" #Create a variable for the report file name
   $zipfiles += $outfile #Create an array for the downloaded zip files
   $report = "$($name.Value)" #Create a variable for the report id
   Invoke-RestMethod -Headers $headers -Uri "https://qualysapi.qualys.com/api/2.0/fo/report/?action=fetch&id=$report" -Method Post -Proxy http://127.0.0.1:8888 -Outfile $working_dir\$outfile #Download the reports to the working directory
}

##Step 7. Correlate names to downloaded zip files into a hash table
$downloaded_reports = @{} #Initialize a hash table
for ( $n = 0; $n -lt $asset_names.Count; $n++ ) { #Find how many assets to iterate through
    $downloaded_reports.Add($asset_names[$n], $zipfiles[$n]) #Combine the asset and zips arrays into a table for iteration
}

##Step 8. Extract the zips in the current working directory
Write-Host Please wait while extracting $report_ids.Count reports.

foreach ($zip in $downloaded_reports.GetEnumerator()) {
    $shell_app=new-object -com shell.application #call .net
    $filename = "$($zip.Value)" #grab the zip name from the hash table
    $zip_file = $shell_app.namespace((Get-Location).Path + "\$filename") #unzip
    $destination = $shell_app.namespace((Get-Location).Path) #destination
    $destination.Copyhere($zip_file.items(), 0x10) #0x10 overwrites destination, 0x14 would combine and overwrite
}

##Step 9. Get the unzipped directories and correlate the names
$zipdir = @() #Initialize an array for the zip directories
foreach ($name in $asset_names) { $zipdir += Get-ChildItem $working_dir -recurse | Where-Object {$_.PSIsContainer -eq $true -and $_.Name -match "$name"} | ForEach-Object {$_.Name}} #Find the unzipped directories

$extract_directories = @{} #Initialize a hash table
for ( $n = 0; $n -lt $asset_names.Count; $n++ ) { #Find how many assets to iterate through
    $extract_directories.Add($asset_names[$n], $zipdir[$n]) #Combine the asset and zipdir arrays into a table for iteration
}

##Step 10. Move the reports and clean up
Write-Host Please wait while copying $report_ids.Count reports. This can be REALLY slow on itportal.

foreach ($move in $extract_directories.GetEnumerator()) { Move-Item "$working_dir\$($move.Value)\*.*" "$report_dir\$($move.Name)\Vuln" -force } #move each report to sharepoint cifs share

Write-Host Cleaning up.
foreach ($deletedir in $extract_directories.GetEnumerator()) { Remove-Item "$working_dir\$($deletedir.Value)\" } #delete extracted folders
foreach ($deletezip in $downloaded_reports.GetEnumerator()) { Remove-Item "$working_dir\$($deletezip.Value)" } #delete downloaded zips

Write-Host Done.